+ 查询的接口方式上的不同 
	
	ES可以查询接口有2个实现的方式，因为是走RestFul的API的风格，可以使用的GET的方案实现，也可以使用的POST的方式实现。使用POST方案在写查询限制条件的时候更方便一些。
		
	` GET /bank/_search?q=*&sort=account_number:asc&pretty `
		
		```
		GET /bank/_search
			{
  			"query": { "match_all": {} },
  			"sort": [
    				{ "account_number": "asc" }
  				]
			}
		```

	ES的查询和传统的查询有一个非常大的不同的地方就是，没一次请求以后服务器端会直接的返回结果，然后查询就结束了，类似于是一个完整的HTTP的请求，无状态的，服务器端不会存有其他的状态的数据，如游标等。（但是为什么上面的查询仅仅返回10个呢？是因为默认的返回数据量配置导致的原因么？）
	> 果然默认是通过size的条件限制的，默认的size的大小是10	

+ 查询的分页的问题

	通过 from 和 size 关键字可以控制返回结构的内容，整个在分页的时候非常的方便。还有一个需要注意的点就是from的是从0开始计算的。

+ 查询的场景 - 关键字
	_source : 确认或者是限制返回值的字段，如果没有需要的字段也不会报错
	query : match 增加查询的匹配的条件,这个match 并不是精确的匹配。查询条件是根据空格分开，是一个Or的关系。
		query : match_phrase 短语，整个的查询条件是作为一个短语在使用。
	query: bool
		- must ---所有的查询条件必须都满足
		- should ---至少满足其中一个查询条件
		- must_not --- 所有的查询条件都不满足
		三种条件可以同时使用，之所有这样的设计，在ES的后台的设计中，应当是做了集合的运算。 	
	filter: 过滤容，算是一个限制的条件，正常情况的查询条件都是计算相关的符合度的值，而加了filter的限制以后就是可以精确的限制相关的数据范围。
	aggs :聚合，聚合比较特别的一个地方就是会返回原始的数据，一个查询中。
	
+ 排序的问题
	ES中对查询结构的排序,特别是的text类型的字段，其是需要开启FiledData为true的属性的，但是这种情况下是需要消耗内存的。
	 
